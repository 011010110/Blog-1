# 1„ÄÅÊ¶ÇËø∞

Êú¨ÊñáÊé•[„ÄäRocketMQÊ∫êÁ†ÅËß£ÊûêÔºöMessageÂèëÈÄÅ&Êé•Êî∂„Äã](https://github.com/YunaiV/Blog/blob/master/RocketMQ/1003-RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9AMessage%E5%8F%91%E9%80%81%26%E6%8E%A5%E6%94%B6.md)„ÄÇ
‰∏ªË¶ÅËß£Êûê `CommitLog` Â≠òÂÇ®Ê∂àÊÅØÈÉ®ÂàÜ„ÄÇËÄÉËôëÂà∞ `CommitLog` ÁöÑÂàùÂßãÂåñÂä†ËΩΩ„ÄÅËøáÊúüÂà†Èô§Êúâ‰∏Ä‰∫õÂÖ≥Á≥ªÔºåÂõ†Ê≠§Ôºå‰∏ÄËµ∑‰∏ÄËµ∑üòà„ÄÇ

# 2„ÄÅCommitLog ÁªìÊûÑ

`CommitLog`„ÄÅ`MappedFileQueue`„ÄÅ`MappedFile` ÁöÑÂÖ≥Á≥ªÂ¶Ç‰∏ãÔºö

> ![CommitLog„ÄÅMappedFileQueue„ÄÅMappedFileÁöÑÂÖ≥Á≥ª](images/1004/CommitLog&MappedQueue&MappedFileÁ±ªÂõæ.png)
`CommitLog` : `MappedQueue` : `MappedFile` = 1 : 1 : N„ÄÇ

ÂèçÂ∫îÂà∞Á≥ªÁªüÊñá‰ª∂Â¶Ç‰∏ãÔºö

```bash
Yunai-MacdeMacBook-Pro-2:commitlog yunai$ pwd
/Users/yunai/store/commitlog
Yunai-MacdeMacBook-Pro-2:commitlog yunai$ ls -l
total 10485760
-rw-r--r--  1 yunai  staff  1073741824  4 21 16:27 00000000000000000000
-rw-r--r--  1 yunai  staff  1073741824  4 21 16:29 00000000001073741824
-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000002147483648
-rw-r--r--  1 yunai  staff  1073741824  4 21 16:33 00000000003221225472
-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000004294967296
```

-------

`CommitLog`„ÄÅ`MappedFileQueue`„ÄÅ`MappedFile` ÁöÑÂÆö‰πâÂ¶Ç‰∏ãÔºö

* `MappedFile` Ôºö00000000000000000000„ÄÅ00000000001073741824„ÄÅ00000000002147483648Á≠âÊñá‰ª∂„ÄÇ
* `MappedFileQueue` Ôºö`MappedFile` ÊâÄÂú®ÁöÑÊñá‰ª∂Â§πÔºåÂØπ `MappedFile` ËøõË°åÂ∞ÅË£ÖÊàêÊñá‰ª∂ÈòüÂàóÔºåÂØπ‰∏äÂ±ÇÊèê‰æõÂèØÊó†Èôê‰ΩøÁî®ÁöÑÊñá‰ª∂ÂÆπÈáè„ÄÇ
    * ÊØè‰∏™ `MappedFile` Áªü‰∏ÄÊñá‰ª∂Â§ßÂ∞è„ÄÇ
    * Êñá‰ª∂ÂëΩÂêçÊñπÂºèÔºöfileName[n] = fileName[n - 1] + mappedFileSize„ÄÇÂú® `CommitLog` ÈáåÈªòËÆ§‰∏∫ 1GB„ÄÇ
* `CommitLog` ÔºöÈíàÂØπ `MappedFileQueue` ÁöÑÂ∞ÅË£Ö‰ΩøÁî®„ÄÇ

`CommitLog` ÁõÆÂâçÂ≠òÂÇ®Âú® `MappedFile` Êúâ‰∏§ÁßçÂÜÖÂÆπÁ±ªÂûãÔºö

1. MESSAGE ÔºöÊ∂àÊÅØ„ÄÇ
2. BLANK ÔºöÊñá‰ª∂‰∏çË∂≥‰ª•Â≠òÂÇ®Ê∂àÊÅØÊó∂ÁöÑÁ©∫ÁôΩÂç†‰Ωç„ÄÇ

`CommitLog` Â≠òÂÇ®Âú® `MappedFile`ÁöÑÁªìÊûÑÔºö

> | MESSAGE[1] | MESSAGE[2]  | ... | MESSAGE[n - 1] | MESSAGE[n] | BLANK |
> | --- | --- | --- | --- | --- | --- |

`MESSAGE` Âú® `CommitLog` Â≠òÂÇ®ÁªìÊûÑÔºö

| Á¨¨Âá†‰Ωç | Â≠óÊÆµ | ËØ¥Êòé | Êï∞ÊçÆÁ±ªÂûã | Â≠óËäÇÊï∞ |
| :-- | :-- | :-- | :-- | :-- |
| 1 | MsgLen | Ê∂àÊÅØÊÄªÈïøÂ∫¶ | Int | 4 |
| 2 | MagicCode | MESSAGE_MAGIC_CODE | Int | 4 |
| 3 | BodyCRC | Ê∂àÊÅØÂÜÖÂÆπCRC | Int | 4 |
| 4 | QueueId | Ê∂àÊÅØÈòüÂàóÁºñÂè∑ | Int | 4 |
| 5 | Flag |   |  |  |
| 6 | QueueOffset | Ê∂àÊÅØÈòüÂàó‰ΩçÁΩÆ | Long | 8 |
| 7 | PhysicalOffset | Áâ©ÁêÜ‰ΩçÁΩÆ„ÄÇÂú® `CommitLog` ÁöÑÈ°∫Â∫èÂ≠òÂÇ®‰ΩçÁΩÆ„ÄÇ | Long | 8 |
| 8 | SysFlag |  | Int | 4 |
| 9 | BornTimestamp | ÁîüÊàêÊ∂àÊÅØÊó∂Èó¥Êà≥ | Long | 8 |
| 10 | BornHost  | ÁîüÊïàÊ∂àÊÅØÁöÑÂú∞ÂùÄ+Á´ØÂè£ | Long | 8 |
| 11 | StoreTimestamp | Â≠òÂÇ®Ê∂àÊÅØÊó∂Èó¥Êà≥ | Long | 8 |
| 12 | StoreHost | Â≠òÂÇ®Ê∂àÊÅØÁöÑÂú∞ÂùÄ+Á´ØÂè£ | Long | 8 |
| 13 | ReconsumeTimes | ÈáçÊñ∞Ê∂àË¥πÊ∂àÊÅØÊ¨°Êï∞ | Int | 4 |
| 14 | PreparedTransationOffset |  | Long | 8 |
| 15 | BodyLength + Body  | ÂÜÖÂÆπÈïøÂ∫¶ + ÂÜÖÂÆπ | Int + Bytes | 4 + bodyLength |
| 16 | TopicLength + Topic | TopicÈïøÂ∫¶ + Topic | Byte + Bytes | 1 + topicLength |
| 17 | PropertiesLength + Properties | ÊãìÂ±ïÂ≠óÊÆµÈïøÂ∫¶ + ÊãìÂ±ïÂ≠óÊÆµ | Short + Bytes | 2 + PropertiesLength |

`BLANK` Âú® `CommitLog` Â≠òÂÇ®ÁªìÊûÑÔºö

| Á¨¨Âá†‰Ωç | Â≠óÊÆµ | ËØ¥Êòé | Êï∞ÊçÆÁ±ªÂûã | Â≠óËäÇÊï∞ |
| :-- | :-- | :-- | :-- | :-- |
| 1 | maxBlank | Á©∫ÁôΩÈïøÂ∫¶ | Int | 4 |
| 2 | MagicCode | BLANK_MAGIC_CODE | Int | 4 |

# 3„ÄÅCommitLog Â≠òÂÇ®Ê∂àÊÅØ

> ![BrokerÂ≠òÂÇ®ÂèëÈÄÅÊ∂àÊÅØÈ°∫Â∫èÂõæ](images/1004/BrokerÂ≠òÂÇ®ÂèëÈÄÅÊ∂àÊÅØÈ°∫Â∫èÂõæ.png)

## CommitLog#putMessage(...)

```Java
  1: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {
  2:     // Set the storage time
  3:     msg.setStoreTimestamp(System.currentTimeMillis());
  4:     // Set the message body BODY CRC (consider the most appropriate setting
  5:     // on the client)
  6:     msg.setBodyCRC(UtilAll.crc32(msg.getBody()));
  7:     // Back to Results
  8:     AppendMessageResult result = null;
  9: 
 10:     StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();
 11: 
 12:     String topic = msg.getTopic();
 13:     int queueId = msg.getQueueId();
 14: 
 15:     // ‰∫ãÂä°Áõ∏ÂÖ≥ TODO ÂæÖËØªÔºö‰∫ãÂä°Áõ∏ÂÖ≥
 16:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());
 17:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//
 18:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {
 19:         // Delay Delivery
 20:         if (msg.getDelayTimeLevel() > 0) {
 21:             if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {
 22:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());
 23:             }
 24: 
 25:             topic = ScheduleMessageService.SCHEDULE_TOPIC;
 26:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());
 27: 
 28:             // Backup real topic, queueId
 29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());
 30:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));
 31:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));
 32: 
 33:             msg.setTopic(topic);
 34:             msg.setQueueId(queueId);
 35:         }
 36:     }
 37: 
 38:     long eclipseTimeInLock = 0;
 39: 
 40:     // Ëé∑ÂèñÂÜôÂÖ•Êò†Â∞ÑÊñá‰ª∂
 41:     MappedFile unlockMappedFile = null;
 42:     MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();
 43: 
 44:     // Ëé∑ÂèñÂÜôÂÖ•ÈîÅ
 45:     lockForPutMessage(); //spin...
 46:     try {
 47:         long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();
 48:         this.beginTimeInLock = beginLockTimestamp;
 49: 
 50:         // Here settings are stored timestamp, in order to ensure an orderly
 51:         // global
 52:         msg.setStoreTimestamp(beginLockTimestamp);
 53: 
 54:         // ÂΩì‰∏çÂ≠òÂú®Êò†Â∞ÑÊñá‰ª∂Êó∂ÔºåËøõË°åÂàõÂª∫
 55:         if (null == mappedFile || mappedFile.isFull()) {
 56:             mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise
 57:         }
 58:         if (null == mappedFile) {
 59:             log.error("create maped file1 error, topic: " + msg.getTopic() + " clientAddr: " + msg.getBornHostString());
 60:             beginTimeInLock = 0;
 61:             return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);
 62:         }
 63: 
 64:         // Â≠òÂÇ®Ê∂àÊÅØ
 65:         result = mappedFile.appendMessage(msg, this.appendMessageCallback);
 66:         switch (result.getStatus()) {
 67:             case PUT_OK:
 68:                 break;
 69:             case END_OF_FILE: // ÂΩìÊñá‰ª∂Â∞æÊó∂ÔºåËé∑ÂèñÊñ∞ÁöÑÊò†Â∞ÑÊñá‰ª∂ÔºåÂπ∂ËøõË°åÊèíÂÖ•
 70:                 unlockMappedFile = mappedFile;
 71:                 // Create a new file, re-write the message
 72:                 mappedFile = this.mappedFileQueue.getLastMappedFile(0);
 73:                 if (null == mappedFile) {
 74:                     // XXX: warn and notify me
 75:                     log.error("create maped file2 error, topic: " + msg.getTopic() + " clientAddr: " + msg.getBornHostString());
 76:                     beginTimeInLock = 0;
 77:                     return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);
 78:                 }
 79:                 result = mappedFile.appendMessage(msg, this.appendMessageCallback);
 80:                 break;
 81:             case MESSAGE_SIZE_EXCEEDED:
 82:             case PROPERTIES_SIZE_EXCEEDED:
 83:                 beginTimeInLock = 0;
 84:                 return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);
 85:             case UNKNOWN_ERROR:
 86:                 beginTimeInLock = 0;
 87:                 return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);
 88:             default:
 89:                 beginTimeInLock = 0;
 90:                 return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);
 91:         }
 92: 
 93:         eclipseTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;
 94:         beginTimeInLock = 0;
 95:     } finally {
 96:         // ÈáäÊîæÂÜôÂÖ•ÈîÅ
 97:         releasePutMessageLock();
 98:     }
 99: 
100:     if (eclipseTimeInLock > 500) {
101:         log.warn("[NOTIFYME]putMessage in lock cost time(ms)={}, bodyLength={} AppendMessageResult={}", eclipseTimeInLock, msg.getBody().length, result);
102:     }
103: 
104:     // 
105:     if (null != unlockMappedFile && this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {
106:         this.defaultMessageStore.unlockMappedFile(unlockMappedFile);
107:     }
108: 
109:     PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);
110: 
111:     // Statistics
112:     storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();
113:     storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());
114: 
115:     // ËøõË°åÂêåÊ≠•||ÂºÇÊ≠• flush||commit
116:     GroupCommitRequest request = null;
117:     // Synchronization flush
118:     if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {
119:         final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;
120:         if (msg.isWaitStoreMsgOK()) {
121:             request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());
122:             service.putRequest(request);
123:             boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());
124:             if (!flushOK) {
125:                 log.error("do groupcommit, wait for flush failed, topic: " + msg.getTopic() + " tags: " + msg.getTags()
126:                     + " client address: " + msg.getBornHostString());
127:                 putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);
128:             }
129:         } else {
130:             service.wakeup();
131:         }
132:     }
133:     // Asynchronous flush
134:     else {
135:         if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {
136:             flushCommitLogService.wakeup(); // importantÔºöÂî§ÈÜícommitLogÁ∫øÁ®ãÔºåËøõË°åflush
137:         } else {
138:             commitLogService.wakeup();
139:         }
140:     }
141: 
142:     // Synchronous write double Â¶ÇÊûúÊòØÂêåÊ≠•MasterÔºåÂêåÊ≠•Âà∞‰ªéËäÇÁÇπ // TODO ÂæÖËØªÔºöÊï∞ÊçÆÂêåÊ≠•
143:     if (BrokerRole.SYNC_MASTER == this.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) {
144:         HAService service = this.defaultMessageStore.getHaService();
145:         if (msg.isWaitStoreMsgOK()) {
146:             // Determine whether to wait
147:             if (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) {
148:                 if (null == request) {
149:                     request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());
150:                 }
151:                 service.putRequest(request);
152: 
153:                 service.getWaitNotifyObject().wakeupAll();
154: 
155:                 boolean flushOK =
156:                     // TODO
157:                     request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());
158:                 if (!flushOK) {
159:                     log.error("do sync transfer other node, wait return, but failed, topic: " + msg.getTopic() + " tags: "
160:                         + msg.getTags() + " client address: " + msg.getBornHostString());
161:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);
162:                 }
163:             }
164:             // Slave problem
165:             else {
166:                 // Tell the producer, slave not available
167:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);
168:             }
169:         }
170:     }
171: 
172:     return putMessageResult;
173: }
```

* ËØ¥Êòé ÔºöÂ≠òÂÇ®Ê∂àÊÅØÔºåÂπ∂ËøîÂõûÂ≠òÂÇ®ÁªìÊûú„ÄÇ
* Á¨¨ 2 Ë°å ÔºöËÆæÁΩÆÂ≠òÂÇ®Êó∂Èó¥Á≠â„ÄÇ
* Á¨¨ 16 Ëá≥ 36 Ë°å Ôºö‰∫ãÂä°Ê∂àÊÅØÁõ∏ÂÖ≥ÔºåÊöÇÊú™‰∫ÜËß£„ÄÇ
* Á¨¨ 45 & 97 Ë°å ÔºöËé∑ÂèñÈîÅ‰∏éÈáäÊîæÈîÅ„ÄÇ
* Á¨¨ 52 Ë°å ÔºöÂÜçÊ¨°ËÆæÁΩÆÂ≠òÂÇ®Êó∂Èó¥„ÄÇÁõÆÂâç‰ºöÊúâÂ§öÂ§ÑÂú∞ÊñπËÆæÁΩÆÂ≠òÂÇ®Êó∂Èó¥„ÄÇ
* Á¨¨ 55 Ëá≥ 62 Ë°å ÔºöËé∑Âèñ `MappedFile`ÔºåËã•‰∏çÂ≠òÂú®ÊàñÂ∑≤Êª°ÔºåÂàôËøõË°åÂàõÂª∫„ÄÇËØ¶ÁªÜËß£ÊûêËßÅÔºö[MappedFileQueue#getLastMappedFile(...)](#mappedfilequeuegetlastmappedfile)„ÄÇ
* Á¨¨ 65 Ë°å Ôºö**ÊèíÂÖ•Ê∂àÊÅØ**Âà∞ `MappedFile`ÔºåËß£ÊûêËß£ÊûêËßÅÔºö[MappedFile#appendMessage(...)](#mappedfileappendmessage)„ÄÇ
* Á¨¨ 69 Ëá≥ 80 Ë°å Ôºö`MappedFile` Â∑≤Êª°ÔºåÂàõÂª∫Êñ∞ÁöÑÔºåÂÜçÊ¨°**ÊèíÂÖ•Ê∂àÊÅØ**„ÄÇ
* Á¨¨ 116 Ëá≥ 140 Ë°å Ôºö**Ê∂àÊÅØÂà∑Áõò**ÔºåÂç≥ÊåÅ‰πÖÂåñÂà∞Êñá‰ª∂„ÄÇ‰∏äÈù¢**ÊèíÂÖ•Ê∂àÊÅØ**ÂÆûÈôÖÊú™Â≠òÂÇ®Âà∞Á°¨Áõò„ÄÇÊ≠§Â§ÑÔºåÊ†πÊçÆ‰∏çÂêåÁöÑÂà∑ÁõòÁ≠ñÁï•ÔºåÊâßË°å‰ºöÊúâ‰∏çÂêå„ÄÇËØ¶ÁªÜËß£ÊûêËßÅÔºö[FlushCommitLogService](#flushcommitlogservice)„ÄÇ
* Á¨¨ 143 Ëá≥ 173 Ë°å Ôºö`Broker` ‰∏ª‰ªéÂêåÊ≠•„ÄÇÂêéÈù¢ÁöÑÊñáÁ´†‰ºöËØ¶ÁªÜËß£Êûêüòà„ÄÇ

## MappedFileQueue#getLastMappedFile(...)

```Java
  1: public MappedFile getLastMappedFile(final long startOffset, boolean needCreate) {
  2:     long createOffset = -1; // ÂàõÂª∫Êñá‰ª∂ÂºÄÂßãoffset„ÄÇ-1Êó∂Ôºå‰∏çÂàõÂª∫
  3:     MappedFile mappedFileLast = getLastMappedFile();
  4: 
  5:     if (mappedFileLast == null) { // ‰∏Ä‰∏™Êò†Â∞ÑÊñá‰ª∂ÈÉΩ‰∏çÂ≠òÂú®
  6:         createOffset = startOffset - (startOffset % this.mappedFileSize);
  7:     }
  8: 
  9:     if (mappedFileLast != null && mappedFileLast.isFull()) { // ÊúÄÂêé‰∏Ä‰∏™Êñá‰ª∂Â∑≤Êª°
 10:         createOffset = mappedFileLast.getFileFromOffset() + this.mappedFileSize;
 11:     }
 12: 
 13:     if (createOffset != -1 && needCreate) { // ÂàõÂª∫Êñá‰ª∂
 14:         String nextFilePath = this.storePath + File.separator + UtilAll.offset2FileName(createOffset);
 15:         String nextNextFilePath = this.storePath + File.separator
 16:             + UtilAll.offset2FileName(createOffset + this.mappedFileSize);
 17:         MappedFile mappedFile = null;
 18: 
 19:         if (this.allocateMappedFileService != null) {
 20:             mappedFile = this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,
 21:                 nextNextFilePath, this.mappedFileSize);
 22:         } else {
 23:             try {
 24:                 mappedFile = new MappedFile(nextFilePath, this.mappedFileSize);
 25:             } catch (IOException e) {
 26:                 log.error("create mappedFile exception", e);
 27:             }
 28:         }
 29: 
 30:         if (mappedFile != null) {
 31:             if (this.mappedFiles.isEmpty()) {
 32:                 mappedFile.setFirstCreateInQueue(true);
 33:             }
 34:             this.mappedFiles.add(mappedFile);
 35:         }
 36: 
 37:         return mappedFile;
 38:     }
 39: 
 40:     return mappedFileLast;
 41: }
```

* ËØ¥Êòé ÔºöËé∑ÂèñÊúÄÂêé‰∏Ä‰∏™ `MappedFile`ÔºåËã•‰∏çÂ≠òÂú®ÊàñÊñá‰ª∂Â∑≤Êª°ÔºåÂàôËøõË°åÂàõÂª∫„ÄÇ
* Á¨¨ 5 Ëá≥ 11 Ë°å ÔºöËÆ°ÁÆóÂΩìÊñá‰ª∂‰∏çÂ≠òÂú®ÊàñÂ∑≤Êª°Êó∂ÔºåÊñ∞ÂàõÂª∫Êñá‰ª∂ÁöÑ `createOffset`„ÄÇ
* Á¨¨ 14 Ë°å ÔºöËÆ°ÁÆóÊñá‰ª∂Âêç„ÄÇ‰ªéÊ≠§Â§ÑÊàë‰ª¨ÂèØ
‰ª•ÂæóÁü•Ôºå`MappedFile`ÁöÑÊñá‰ª∂ÂëΩÂêçËßÑÂàôÔºö

    > fileName[n] = fileName[n - 1] + n * mappedFileSize
    > fileName[0] = startOffset - (startOffset % this.mappedFileSize)
    
    ÁõÆÂâç `CommitLog` ÁöÑ `startOffset` ‰∏∫ 0„ÄÇ
    Ê≠§Â§ÑÊúâ‰∏™**ÁñëÈóÆ**Ôºå‰∏∫‰ªÄ‰πàÈúÄË¶Å `(startOffset % this.mappedFileSize)`„ÄÇ‰æãÂ¶ÇÔºö
    
    | startOffset  | mappedFileSize | createOffset |
    | --- | :-- | :-- |
    | 5 | 1 | 5 |
    | 5 | 2 | 4 |
    | 5 | 3 | 3  |
    | 5 | 4 | 4 |
    | 5 | > 5 | 0 |
    
    _Â¶ÇÊûúÊúâÁü•ÈÅìÁöÑÂêåÂ≠¶ÔºåÈ∫ªÁÉ¶ÊèêÁ§∫‰∏ã„ÄÇüòà_
    
* Á¨¨ 30 Ëá≥ 35 Ë°å ÔºöËÆæÁΩÆ `MappedFile`ÊòØÂê¶ÊòØÁ¨¨‰∏Ä‰∏™ÂàõÂª∫ÁöÑÊñá‰ª∂„ÄÇËØ•Ê†áËØÜÁî®‰∫é `ConsumeQueue` ÂØπÂ∫îÁöÑ `MappedFile` ÔºåËØ¶ËßÅ `ConsumeQueue#fillPreBlank`„ÄÇ
    
## MappedFile#appendMessage(...)

```Java
  1: public AppendMessageResult appendMessage(final MessageExtBrokerInner msg, final AppendMessageCallback cb) {
  2:     assert msg != null;
  3:     assert cb != null;
  4: 
  5:     int currentPos = this.wrotePosition.get();
  6: 
  7:     if (currentPos < this.fileSize) {
  8:         ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();
  9:         byteBuffer.position(currentPos);
 10:         AppendMessageResult result =
 11:             cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, msg);
 12:         this.wrotePosition.addAndGet(result.getWroteBytes());
 13:         this.storeTimestamp = result.getStoreTimestamp();
 14:         return result;
 15:     }
 16: 
 17:     log.error("MappedFile.appendMessage return null, wrotePosition: " + currentPos + " fileSize: "
 18:         + this.fileSize);
 19:     return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);
 20: }
```

* ËØ¥Êòé Ôºö**ÊèíÂÖ•Ê∂àÊÅØ**Âà∞ `MappedFile`ÔºåÂπ∂ËøîÂõûÊèíÂÖ•ÁªìÊûú„ÄÇ
* Á¨¨ 8 Ë°å ÔºöËé∑ÂèñÈúÄË¶ÅÂÜôÂÖ•ÁöÑÂ≠óËäÇÁºìÂÜ≤Âå∫„ÄÇ‰∏∫‰ªÄ‰πà‰ºöÊúâ `writeBuffer != null` ÁöÑÂà§Êñ≠ÂêéÔºå‰ΩøÁî®‰∏çÂêåÁöÑÂ≠óËäÇÁºìÂÜ≤Âå∫ÔºåËßÅÔºö[FlushCommitLogService](#flushcommitlogservice)„ÄÇ
* Á¨¨ 9 Ëá≥ 11 Ë°å ÔºöËÆæÁΩÆÂÜôÂÖ• `position`ÔºåÊâßË°åÂÜôÂÖ•ÔºåÊõ¥Êñ∞ `wrotePosition`(ÂΩìÂâçÂÜôÂÖ•‰ΩçÁΩÆÔºå‰∏ãÊ¨°ÂºÄÂßãÂÜôÂÖ•ÂºÄÂßã‰ΩçÁΩÆ)„ÄÇ

## DefaultAppendMessageCallback#doAppend(...)

```Java
  1: class DefaultAppendMessageCallback implements AppendMessageCallback {
  2:     // File at the end of the minimum fixed length empty
  3:     private static final int END_FILE_MIN_BLANK_LENGTH = 4 + 4;
  4:     /**
  5:      * Â≠òÂÇ®Âú®ÂÜÖÂ≠ò‰∏≠ÁöÑÊ∂àÊÅØÁºñÂè∑Â≠óËäÇBuffer
  6:      */
  7:     private final ByteBuffer msgIdMemory;
  8:     /**
  9:      * Store the message content
 10:      * Â≠òÂÇ®Âú®ÂÜÖÂ≠ò‰∏≠ÁöÑÊ∂àÊÅØÂ≠óËäÇBuffer
 11:      * ÂΩìÊ∂àÊÅØ‰º†ÈÄíÂà∞{@link #doAppend(long, ByteBuffer, int, MessageExtBrokerInner)}ÊñπÊ≥ïÊó∂ÔºåÊúÄÁªàÂÜôÂà∞ËØ•ÂèÇÊï∞
 12:      */
 13:     private final ByteBuffer msgStoreItemMemory;
 14:     /**
 15:      * The maximum length of the message
 16:      * Ê∂àÊÅØÊúÄÂ§ßÈïøÂ∫¶
 17:      */
 18:     private final int maxMessageSize;
 19:     /**
 20:      * Build Message Key
 21:      * {@link #topicQueueTable}ÁöÑkey
 22:      * ËÆ°ÁÆóÊñπÂºèÔºötopic + "-" + queueId
 23:      */
 24:     private final StringBuilder keyBuilder = new StringBuilder();
 25:     /**
 26:      * hostÂ≠óËäÇbuffer
 27:      * Áî®‰∫éÈáçÂ§çËÆ°ÁÆóhostÁöÑÂ≠óËäÇÂÜÖÂÆπ
 28:      */
 29:     private final ByteBuffer hostHolder = ByteBuffer.allocate(8);
 30: 
 31:     DefaultAppendMessageCallback(final int size) {
 32:         this.msgIdMemory = ByteBuffer.allocate(MessageDecoder.MSG_ID_LENGTH);
 33:         this.msgStoreItemMemory = ByteBuffer.allocate(size + END_FILE_MIN_BLANK_LENGTH);
 34:         this.maxMessageSize = size;
 35:     }
 36: 
 37:     public ByteBuffer getMsgStoreItemMemory() {
 38:         return msgStoreItemMemory;
 39:     }
 40: 
 41:     public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner) {
 42:         // STORETIMESTAMP + STOREHOSTADDRESS + OFFSET <br>
 43: 
 44:         // PHY OFFSET
 45:         long wroteOffset = fileFromOffset + byteBuffer.position();
 46: 
 47:         // ËÆ°ÁÆócommitLogÈáåÁöÑmsgId
 48:         this.resetByteBuffer(hostHolder, 8);
 49:         String msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);
 50: 
 51:         // Record ConsumeQueue information Ëé∑ÂèñÈòüÂàóoffset
 52:         keyBuilder.setLength(0);
 53:         keyBuilder.append(msgInner.getTopic());
 54:         keyBuilder.append('-');
 55:         keyBuilder.append(msgInner.getQueueId());
 56:         String key = keyBuilder.toString();
 57:         Long queueOffset = CommitLog.this.topicQueueTable.get(key);
 58:         if (null == queueOffset) {
 59:             queueOffset = 0L;
 60:             CommitLog.this.topicQueueTable.put(key, queueOffset);
 61:         }
 62: 
 63:         // Transaction messages that require special handling // TODO ÁñëÈóÆÔºöÁî®ÈÄî
 64:         final int tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());
 65:         switch (tranType) {
 66:             // Prepared and Rollback message is not consumed, will not enter the
 67:             // consumer queue
 68:             case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
 69:             case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
 70:                 queueOffset = 0L;
 71:                 break;
 72:             case MessageSysFlag.TRANSACTION_NOT_TYPE:
 73:             case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
 74:             default:
 75:                 break;
 76:         }
 77: 
 78:         // ËÆ°ÁÆóÊ∂àÊÅØÈïøÂ∫¶
 79:         final byte[] propertiesData =
 80:             msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);
 81:         final int propertiesLength = propertiesData == null ? 0 : propertiesData.length;
 82:         if (propertiesLength > Short.MAX_VALUE) {
 83:             log.warn("putMessage message properties length too long. length={}", propertiesData.length);
 84:             return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);
 85:         }
 86:         final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);
 87:         final int topicLength = topicData.length;
 88:         final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length;
 89:         final int msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);
 90:         // Exceeds the maximum message
 91:         if (msgLen > this.maxMessageSize) {
 92:             CommitLog.log.warn("message size exceeded, msg total size: " + msgLen + ", msg body size: " + bodyLength
 93:                 + ", maxMessageSize: " + this.maxMessageSize);
 94:             return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);
 95:         }
 96: 
 97:         // Determines whether there is sufficient(Ë∂≥Â§ü) free space
 98:         if ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {
 99:             this.resetByteBuffer(this.msgStoreItemMemory, maxBlank);
100:             // 1 TOTAL_SIZE
101:             this.msgStoreItemMemory.putInt(maxBlank);
102:             // 2 MAGIC_CODE
103:             this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);
104:             // 3 The remaining space may be any value
105:             //
106: 
107:             // Here the length of the specially set maxBlank
108:             final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
109:             byteBuffer.put(this.msgStoreItemMemory.array(), 0, maxBlank);
110:             return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),
111:                 queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);
112:         }
113: 
114:         // Initialization of storage space
115:         this.resetByteBuffer(msgStoreItemMemory, msgLen);
116:         // 1 TOTAL_SIZE
117:         this.msgStoreItemMemory.putInt(msgLen);
118:         // 2 MAGIC_CODE
119:         this.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);
120:         // 3 BODY_CRC
121:         this.msgStoreItemMemory.putInt(msgInner.getBodyCRC());
122:         // 4 QUEUE_ID
123:         this.msgStoreItemMemory.putInt(msgInner.getQueueId());
124:         // 5 FLAG
125:         this.msgStoreItemMemory.putInt(msgInner.getFlag());
126:         // 6 QUEUE_OFFSET
127:         this.msgStoreItemMemory.putLong(queueOffset);
128:         // 7 PHYSICAL_OFFSET
129:         this.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());
130:         // 8 SYS_FLAG
131:         this.msgStoreItemMemory.putInt(msgInner.getSysFlag());
132:         // 9 BORN_TIMESTAMP
133:         this.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());
134:         // 10 BORN_HOST
135:         this.resetByteBuffer(hostHolder, 8);
136:         this.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));
137:         // 11 STORE_TIMESTAMP
138:         this.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());
139:         // 12 STORE_HOST_ADDRESS
140:         this.resetByteBuffer(hostHolder, 8);
141:         this.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));
142:         //this.msgStoreItemMemory.put(msgInner.getStoreHostBytes());
143:         // 13 RECONSUME_TIMES
144:         this.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());
145:         // 14 Prepared Transaction Offset
146:         this.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());
147:         // 15 BODY
148:         this.msgStoreItemMemory.putInt(bodyLength);
149:         if (bodyLength > 0)
150:             this.msgStoreItemMemory.put(msgInner.getBody());
151:         // 16 TOPIC
152:         this.msgStoreItemMemory.put((byte) topicLength);
153:         this.msgStoreItemMemory.put(topicData);
154:         // 17 PROPERTIES
155:         this.msgStoreItemMemory.putShort((short) propertiesLength);
156:         if (propertiesLength > 0)
157:             this.msgStoreItemMemory.put(propertiesData);
158: 
159:         final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
160:         // Write messages to the queue buffer
161:         byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);
162: 
163:         AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,
164:             msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);
165: 
166:         switch (tranType) {
167:             case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
168:             case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
169:                 break;
170:             case MessageSysFlag.TRANSACTION_NOT_TYPE:
171:             case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
172:                 // The next update ConsumeQueue information Êõ¥Êñ∞ÈòüÂàóÁöÑoffset
173:                 CommitLog.this.topicQueueTable.put(key, ++queueOffset);
174:                 break;
175:             default:
176:                 break;
177:         }
178:         return result;
179:     }
180: 
181:     /**
182:      * ÈáçÁΩÆÂ≠óËäÇÁºìÂÜ≤Âå∫
183:      *
184:      * @param byteBuffer Â≠óËäÇÁºìÂÜ≤Âå∫
185:      * @param limit ÈïøÂ∫¶
186:      */
187:     private void resetByteBuffer(final ByteBuffer byteBuffer, final int limit) {
188:         byteBuffer.flip();
189:         byteBuffer.limit(limit);
190:     }
191: }
```
* ËØ¥Êòé ÔºöÊèíÂÖ•Ê∂àÊÅØÂà∞Â≠óËäÇÁºìÂÜ≤Âå∫„ÄÇ
* Á¨¨ 45 Ë°å ÔºöËÆ°ÁÆóÁâ©ÁêÜ‰ΩçÁΩÆ„ÄÇÂú® `CommitLog` ÁöÑÈ°∫Â∫èÂ≠òÂÇ®‰ΩçÁΩÆ„ÄÇ
* Á¨¨ 47 Ëá≥ 49 Ë°å ÔºöËÆ°ÁÆó `CommitLog` ÈáåÁöÑ `offsetMsgId`„ÄÇËøôÈáå‰∏ÄÂÆöË¶ÅÂíå `msgId` Âå∫ÂàÜÂºÄ„ÄÇ

|   |   | ËÆ°ÁÆóÊñπÂºè | ÈïøÂ∫¶ | |
| --- | --- | --- | --- |  --- |
| offsetMsgId | BrokerÂ≠òÂÇ®Êó∂ÁîüÊàê | Hex(storeHostBytes, wroteOffset) | 32 |
| msgId | ClientÂèëÈÄÅÊ∂àÊÅØÊó∂ÁîüÊàê | Hex(ËøõÁ®ãÁºñÂè∑, IP, ClassLoader, startTime, currentTime, Ëá™Â¢ûÂ∫èÂàó) | 32 | [„ÄäRocketMQÊ∫êÁ†ÅËß£ÊûêÔºöMessageÂü∫Á°Ä„Äã](https://github.com/YunaiV/Blog/blob/master/RocketMQ/1002-RocketMQÊ∫êÁ†ÅËß£ÊûêÔºöMessageÂü∫Á°Ä.md) |

* Á¨¨ 51 Ëá≥ 61 Ë°å ÔºöËé∑ÂèñÈòüÂàó‰ΩçÁΩÆ(offset)„ÄÇ
* Á¨¨ 78 Ëá≥ 95 Ë°å ÔºöËÆ°ÁÆóÊ∂àÊÅØÊÄªÈïøÂ∫¶„ÄÇ
* Á¨¨ 98 Ëá≥ 112 Ë°å ÔºöÂΩìÊñá‰ª∂Ââ©‰ΩôÁ©∫Èó¥‰∏çË∂≥Êó∂ÔºåÂÜôÂÖ• `BLANK` Âç†‰ΩçÔºåËøîÂõûÁªìÊûú„ÄÇ
* Á¨¨ 114 Ëá≥ 161 Ë°å ÔºöÂÜôÂÖ• `MESSAGE` „ÄÇ
* Á¨¨ 173 Ë°å ÔºöÊõ¥Êñ∞ÈòüÂàó‰ΩçÁΩÆ(offset)„ÄÇ

## FlushCommitLogService

![FlushCommitLogServiceÁ±ªÂõæ](images/1004/FlushCommitLogServiceÁ±ªÂõæ.png)

### MappedFile#ËêΩÁõò


| ÊñπÂºè |   |  |  |
| --- | --- | :-- | :-- |
| ÊñπÂºè‰∏Ä | ÂÜôÂÖ•ÂÜÖÂ≠òÂ≠óËäÇÁºìÂÜ≤Âå∫(writeBuffer) | ‰ªéÂÜÖÂ≠òÂ≠óËäÇÁºìÂÜ≤Âå∫(write buffer)Êèê‰∫§(commit)Âà∞Êñá‰ª∂ÈÄöÈÅì(fileChannel) | Êñá‰ª∂ÈÄöÈÅì(fileChannel)flush |
| ÊñπÂºè‰∫å |  | ÂÜôÂÖ•Êò†Â∞ÑÊñá‰ª∂Â≠óËäÇÁºìÂÜ≤Âå∫(mappedByteBuffer) | Êò†Â∞ÑÊñá‰ª∂Â≠óËäÇÁºìÂÜ≤Âå∫(mappedByteBuffer)flush  |


### FlushRealTimeService

### CommitRealTimeService

### GroupCommitService


# 4„ÄÅCommitLog ÂàùÂßãÂåñÂä†ËΩΩ
# 5„ÄÅCommitLog ËøáÊúüÂà†Èô§

